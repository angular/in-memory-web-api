{"version":3,"sources":["interfaces.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,UAAA,EAAW,MAAO,eAAA,CAAgB;AAU3C;;;;;;;;;EASE;AACF;IAAA;IAiBA,CAAC;IAAD,wBAAC;AAAD,CAjBA,AAiBC,IAAA;;AAED;;EAEE;AACF;IAAA;IAmDA,CAAC;IAAD,gCAAC;AAAD,CAnDA,AAmDC,IAAA;;AAED,iCAAiC;AACjC;;;;;;;EAOE;AAEF;IACE,+BAAY,MAAsC;QAAtC,uBAAA,EAAA,WAAsC;QAChD,MAAM,CAAC,MAAM,CAAC,IAAI,EAAE;YAClB,kBAAkB;YAClB,mBAAmB,EAAE,KAAK;YAC1B,iBAAiB,EAAE,KAAK;YACxB,KAAK,EAAE,GAAG;YACV,SAAS,EAAE,KAAK;YAChB,kBAAkB,EAAE,KAAK;YACzB,OAAO,EAAE,IAAI;YACb,OAAO,EAAE,KAAK;YACd,MAAM,EAAE,IAAI;YACZ,MAAM,EAAE,KAAK;YACb,OAAO,EAAE,SAAS;YAClB,IAAI,EAAE,SAAS;YACf,QAAQ,EAAE,SAAS,CAAC,+DAA+D;SACpF,EAAE,MAAM,CAAC,CAAC;IACb,CAAC;IAQH,4BAAC;AAAD,CAzBA,AAyBC;;AAPM,gCAAU,GAA0B;IAC3C,EAAE,IAAI,EAAE,UAAU,EAAE;CACnB,CAAC;AACF,kBAAkB;AACX,oCAAc,GAAmE,cAAM,OAAA;IAC9F,EAAC,IAAI,EAAE,yBAAyB,GAAG;CAClC,EAF6F,CAE7F,CAAC;AAGF,gDAAgD;AAChD,MAAM,mBAPmB,GAAK;IAQ5B,mFAAmF;IACnF,2CAA2C;IAC3C,IAPM,SAAA,GAAY,kMAAA,CAAmM;IAQrN,IAPM,CAAA,GAAI,SAAA,CAAU,IAAC,CAAI,GAAC,CAAG,CAAC;IAQ9B,IAPM,GAAA,GAAe;QAQnB,MAAM,EAPE,EAAA;QAQR,QAAQ,EAPE,EAAA;QAQV,SAAS,EAPE,EAAA;QAQX,QAAQ,EAPE,EAAA;QAQV,IAAI,EAPE,EAAA;QAQN,QAAQ,EAPE,EAAA;QAQV,IAAI,EAPE,EAAA;QAQN,IAAI,EAPE,EAAA;QAQN,QAAQ,EAPE,EAAA;QAQV,IAAI,EAPE,EAAA;QAQN,SAAS,EAPE,EAAA;QAQX,IAAI,EAPE,EAAA;QAQN,KAAK,EAPE,EAAA;QAQP,MAAM,EAPE,EAAA;KAQT,CAPC;IAQF,IAPM,IAAA,GAAO,MAAA,CAAO,IAAC,CAAI,GAAC,CAAG,CAAC;IAQ9B,IAPI,CAAA,GAAI,IAAA,CAAK,MAAC,CAAM;IASpB,OAAO,CAPC,EAAC,EAAG,CAAA;QAAE,GAAA,CAAI,IAAC,CAAI,CAAC,CAAC,CAAC,GAAG,CAAA,CAAE,CAAC,CAAC,IAAI,EAAA,CAAG;IAAC,CAAA;IAQzC,MAAM,CAPC,GAAA,CAAI;AAQb,CAAC;AA4BD,MAAM,8BAP8B,IAAM;IAQxC,MAAM,CAPC,IAAA,CAAK,OAAC,CAAO,KAAC,EAAM,EAAA,CAAG,CAAC;AAQjC,CAAC","file":"interfaces.js","sourceRoot":"","sourcesContent":["import { Injectable } from '@angular/core';\nimport { Observable } from 'rxjs/Observable';\n\n/**\n *  Minimum definition needed by base class\n */\nexport interface HeadersCore {\n  set(name: string, value: string): void | any;\n}\n\n/**\n* Interface for a class that creates an in-memory database\n*\n* Its `createDb` method creates a hash of named collections that represents the database\n*\n* For maximum flexibility, the service may define HTTP method overrides.\n* Such methods must match the spelling of an HTTP method in lower case (e.g, \"get\").\n* If a request has a matching method, it will be called as in\n* `get(info: requestInfo, db: {})` where `db` is the database object described above.\n*/\nexport abstract class InMemoryDbService {\n  /**\n  * Creates an in-memory \"database\" hash whose keys are collection names\n  * and whose values are arrays of collection objects to return or update.\n  *\n  * returns Observable of the database because could have to create it asynchronously.\n  *\n  * This method must be safe to call repeatedly.\n  * Each time it should return a new object with new arrays containing new item objects.\n  * This condition allows the in-memory backend service to mutate the collections\n  * and their items without touching the original source data.\n  *\n  * The in-mem backend service calls this method without a value the first time.\n  * The service calls it with the `RequestInfo` when it receives a POST `commands/resetDb` request.\n  * Your InMemoryDbService can adjust its behavior accordingly.\n  */\n  abstract createDb(reqInfo?: RequestInfo): {} | Observable<{}> | Promise<{}>;\n}\n\n/**\n* Interface for InMemoryBackend configuration options\n*/\nexport abstract class InMemoryBackendConfigArgs {\n  /**\n   * The base path to the api, e.g, 'api/'.\n   * If not specified than `parseRequestUrl` assumes it is the first path segment in the request.\n   */\n  apiBase?: string;\n  /**\n   * false (default) if search match should be case insensitive\n   */\n  caseSensitiveSearch?: boolean;\n  /**\n   * false (default) put content directly inside the response body.\n   * true: encapsulate content in a `data` property inside the response body, `{ data: ... }`.\n   */\n  dataEncapsulation?: boolean;\n  /**\n   * delay (in ms) to simulate latency\n   */\n  delay?: number;\n  /**\n   * false (default) should 204 when object-to-delete not found; true: 404\n   */\n  delete404?: boolean;\n  /**\n   * host for this service, e.g., 'localhost'\n   */\n  host?: string;\n  /**\n   * false (default) should pass unrecognized request URL through to original backend; true: 404\n   */\n  passThruUnknownUrl?: boolean;\n  /**\n   * true (default) should NOT return the item (204) after a POST. false: return the item (200).\n   */\n  post204?: boolean;\n  /**\n  * false (default) should NOT update existing item with POST. false: OK to update.\n  */\n  post409?: boolean;\n  /**\n  * true (default) should NOT return the item (204) after a POST. false: return the item (200).\n  */\n  put204?: boolean;\n  /**\n   * false (default) if item not found, create as new item; false: should 404.\n   */\n  put404?: boolean;\n  /**\n   * root path _before_ any API call, e.g., ''\n   */\n  rootPath?: string;\n}\n\n/////////////////////////////////\n/**\n*  InMemoryBackendService configuration options\n*  Usage:\n*    InMemoryWebApiModule.forRoot(InMemHeroService, {delay: 600})\n*\n*  or if providing separately:\n*    provide(InMemoryBackendConfig, {useValue: {delay: 600}}),\n*/\n\nexport class InMemoryBackendConfig implements InMemoryBackendConfigArgs {\n  constructor(config: InMemoryBackendConfigArgs = {}) {\n    Object.assign(this, {\n      // default config:\n      caseSensitiveSearch: false,\n      dataEncapsulation: false, // do NOT wrap content within an object with a `data` property\n      delay: 500, // simulate latency by delaying response\n      delete404: false, // don't complain if can't find entity to delete\n      passThruUnknownUrl: false, // 404 if can't process URL\n      post204: true, // don't return the item after a POST\n      post409: false, // don't update existing item with that ID\n      put204: true,  // don't return the item after a PUT\n      put404: false, // create new item if PUT item with that ID not found\n      apiBase: undefined, // assumed to be the first path segment\n      host: undefined,    // default value is actually set in InMemoryBackendService ctor\n      rootPath: undefined // default value is actually set in InMemoryBackendService ctor\n    }, config);\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/** @nocollapse */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: InMemoryBackendConfigArgs, },\n];\n}\n\n/** Return information (UriInfo) about a URI  */\nexport function parseUri(str: string): UriInfo {\n  // Adapted from parseuri package - http://blog.stevenlevithan.com/archives/parseuri\n  // tslint:disable-next-line:max-line-length\n  const URL_REGEX = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n  const m = URL_REGEX.exec(str);\n  const uri: UriInfo = {\n    source: '',\n    protocol: '',\n    authority: '',\n    userInfo: '',\n    user: '',\n    password: '',\n    host: '',\n    port: '',\n    relative: '',\n    path: '',\n    directory: '',\n    file: '',\n    query: '',\n    anchor: ''\n  };\n  const keys = Object.keys(uri);\n  let i = keys.length;\n\n  while (i--) { uri[keys[i]] = m[i] || ''; }\n  return uri;\n}\n\n/**\n *\n * Interface for the result of the `parseRequestUrl` method:\n *   Given URL \"http://localhost:8080/api/customers/42?foo=1 the default implementation returns\n *     base: 'api/'\n *     collectionName: 'customers'\n *     id: '42'\n *     query: this.createQuery('foo=1')\n *     resourceUrl: 'http://localhost/api/customers/'\n */\nexport interface ParsedRequestUrl {\n  apiBase: string;           // the slash-terminated \"base\" for api requests (e.g. `api/`)\n  collectionName: string; // the name of the collection of data items (e.g.,`customers`)\n  id: string;             // the (optional) id of the item in the collection (e.g., `42`)\n  query: Map<string, string[]>; // the query parameters;\n  resourceUrl: string;    // the effective URL for the resource (e.g., 'http://localhost/api/customers/')\n}\n\nexport interface PassThruBackend {\n  /**\n   * Handle an HTTP request and return an Observable of HTTP response\n   * Both the request type and the response type are determined by the supporting HTTP library.\n   */\n  handle(req: any): Observable<any>;\n}\n\nexport function removeTrailingSlash(path: string) {\n  return path.replace(/\\/$/, '');\n}\n\n/**\n *  Minimum definition needed by base class\n */\nexport interface RequestCore {\n  url: string;\n}\n\n/**\n* Interface for object w/ info about the current request url\n* extracted from an Http Request.\n* Also holds utility methods and configuration data from this service\n*/\nexport interface RequestInfo {\n  req: RequestCore; // concrete type depends upon the Http library\n  apiBase: string;\n  collectionName: string;\n  collection: any;\n  headers: HeadersCore;\n  method: string;\n  id: any;\n  query: Map<string, string[]>;\n  resourceUrl: string;\n  url: string; // request URL\n  utils: RequestInfoUtilities;\n}\n\n/**\n * Interface for utility methods from this service instance.\n * Useful within an HTTP method override\n */\nexport interface RequestInfoUtilities {\n  /**\n   * Create a cold response Observable from a factory for ResponseOptions\n   * the same way that the in-mem backend service does.\n   * @param resOptionsFactory - creates ResponseOptions when observable is subscribed\n   * @param withDelay - if true (default), add simulated latency delay from configuration\n   */\n  createResponse$: (resOptionsFactory: () => ResponseOptions) => Observable<any>;\n\n  /**\n   * Find first instance of item in collection by `item.id`\n   * @param collection\n   * @param id\n   */\n  findById<T extends { id: any }>(collection: T[], id: any): T;\n\n  /** return the current, active configuration which is a blend of defaults and overrides */\n  getConfig(): InMemoryBackendConfigArgs;\n\n  /** Get the in-mem service's copy of the \"database\" */\n  getDb(): {};\n\n  /** Get JSON body from the request object */\n  getJsonBody(req: any): any;\n\n  /** Get location info from a url, even on server where `document` is not defined */\n  getLocation(url: string): UriInfo;\n\n  /** Get (or create) the \"real\" backend */\n  getPassThruBackend(): PassThruBackend;\n\n  /**\n   * return true if can determine that the collection's `item.id` is a number\n   * */\n  isCollectionIdNumeric<T extends { id: any }>(collection: T[], collectionName: string): boolean;\n\n  /**\n   * Parses the request URL into a `ParsedRequestUrl` object.\n   * Parsing depends upon certain values of `config`: `apiBase`, `host`, and `urlRoot`.\n   */\n  parseRequestUrl(url: string): ParsedRequestUrl;\n}\n\n/**\n * Provide a `responseInterceptor` method of this type in your `inMemDbService` to\n * morph the response options created in the `collectionHandler`.\n */\nexport type ResponseInterceptor = (res: ResponseOptions, ri: RequestInfo) => ResponseOptions;\n\nexport interface ResponseOptions {\n  /**\n   * String, Object, ArrayBuffer or Blob representing the body of the {@link Response}.\n   */\n  body?: string | Object | ArrayBuffer | Blob;\n\n  /**\n   * Response headers\n   */\n  headers?: HeadersCore;\n\n  /**\n   * Http {@link http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html status code}\n   * associated with the response.\n   */\n  status?: number;\n\n  /**\n   * Status text for the status code\n   */\n  statusText?: string;\n  /**\n   * request url\n   */\n  url?: string;\n}\n\n/** Interface of information about a Uri  */\nexport interface UriInfo {\n  source: string;\n  protocol: string;\n  authority: string;\n  userInfo: string;\n  user: string;\n  password: string;\n  host: string;\n  port: string;\n  relative: string;\n  path: string;\n  directory: string;\n  file: string;\n  query: string;\n  anchor: string;\n}\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n"]}